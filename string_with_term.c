/*
 * WEB+DB PRESS総集編 Vol.1-36
 * データ構造
 *
 * 終端文字列(\0)を最後に付けた文字列
 */

#include <stdlib.h>
#include <stdio.h>

// 文字列を標準出力に出力する関数
void
put_str(char *s)
{
  // '\0'でないかぎりポインタを進めながらループ
  for(; *s != '\0'; s++) {
    // ポインタが指す1文字を標準出力に出力
    putchar(*s);
  }
  // 最後に改行を出力
  putchar('\n');
}

// 文字列の長さを返す関数
int
len_str(char *s)
{
  // 文字列のポインタの初期値を記憶しておく変数
  char *s_save;

  // ポインタの初期値をセーブしておく
  s_save = s;
  // '\0'に達するまでポインタを進める
  while (*s != '\0') {
    s++;
  }

  // 現在のポインタから初期値を引けば文字数になる
  return s - s_save;
}


// 2つの文字列を連結し、連結後の文字列を返す関数
char *
cat_str(char *s1, char *s2)
{
  // 連結後の文字列用のポインタ
  char *s, *s_save;
  // 連結後の文字列の長さ分のメモリを確保
  s = malloc(len_str(s1) + len_str(s2) + 1); // +1は'\0'の分
  s_save = s;  // 連結後の文字列用のポインタをセーブ

  // '\0'になるまでs1の文字列をコピー
  while ((*s++ = *s1++) != '\0');

  s--; // '\0'のところにポインタを戻す

  // 続けて'\0'になるまでs2の文字列をコピー
  while ((*s++ = *s2++) != '\0');

  // 連結後の文字列を指しているポインタを返す
  return s_save;
}

int
main()
{
  char *s1, *s2, *s3; // テスト文字列用ポインタ

  s1 = malloc(5 + 1); // 文字列 + 1('\0'の分) のメモリを確保
  s1[0] = 'H';
  s1[1] = 'e';
  s1[2] = 'l';
  s1[3] = 'l';
  s1[4] = 'o';
  s1[5] = '\0';

  put_str(s1);

  s2 = malloc(7 + 1); // 文字列 + 1('\0'の分) のメモリを確保
  s2[0] = 'W';
  s2[1] = 'o';
  s2[2] = 'r';
  s2[3] = 'l';
  s2[4] = 'd';
  s2[5] = '!';
  s2[6] = '!';
  s2[7] = '\0';
  
  put_str(s2);

  s3 = cat_str(s1, s2); // s1とs2を連結し、s3に代入
  printf("length = %d\n", len_str(s3));
  put_str(s3);

  return 0;
}
